\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{hyperref}

\title{\texttt{picOS} : Petite Implémentation en C d'un OS}
\author{Martin Janin, Antonin Reitz, Jules Saget}
\date{2018}

\begin{document}

\maketitle

\section{Vue d'ensemble}

\subsection{Objectifs et spécifications}

\texttt{picOS} est un micronoyau pour i386-elf. Dans un premier temps, nous
voulions coder un système d'exploitation pour architecture x86\_64, avec
pagination et système de fichier. Au final, nous avons un ordonanceur une
interface utilisateur-machine avancée, et un début de pagination.

Toutes les fonctionnalités de notre OS ont été intégralement codées par nos
soins, à l'exception notable du chargeur d'amorçage. Nous nous sommes beaucoup
inspirés des articles d'OSDev (\url{osdev.org}), mais tout notre code est
original.

\subsection{Architecture générale}

L'architecture est inspirée du \emph{Meaty Skeleton} d'OSDev. Elle se divise en
trois grandes parties~:
\begin{itemize}
  \item Le noyau : le dossier \texttt{kernel} contient toutes les fonctions
    relatives au noyau. Cela comporte notamment tout ce qui est dépendant du
    processeur (éditeur de lien, périphérique clavier, \ldots) ainsi que toutes
    les sources permettant de compiler le noyau.
  \item La bibliothèque C : le dossier \texttt{libc} contient toutes les
    fonctions relatives au noyau. Cela comporte l'interface pour les appels
    système, l'ordonanceur, les structures de données et l'allocation mémoire.
  \item Les scripts : le dossier \texttt{scripts} contiens tous les scripts
    nécessaires à la compilation. C'est ce qui relie les différentes parties
    entre pour construire l'image disque.
\end{itemize}

\section{Aspects techniques}

\subsection{Utilitaires externes}

Pour nous faciliter la tâche, nous avons eu recours à différents utilitaires
externes. Outre les outils standards (comme l'utilisation de Git ou de
Makefiles), nous nous sommes servis du chargeur d'amorçage GRUB et du simulateur
de machine virtuelle Qemu.

\subsubsection{Git}

Tout notre code est accessible sur le dépôt Git situé à l'adresse suivante :
\url{https://github.com/Involture/picOS}. La branche Master contient tout le
code compilable (à quelques erreurs près). La branche Testing contient le code
codé mais pas stable, ou pour lequel il manque des fonctions non codées. Enfin,
la branche Rendu contient la version du projet présentée à la soutenance.

\subsubsection{GCC et compilation croisée}

Notre système d'exploitation étant codé en C, nous avons utilisé GCC pour le
compiler. Néanmoins, puisque nous compilons pour une autre machine que celles
sur lesquelles nous travaillons (notre système d'exploitation est conçu pour
architecture i386-elf), nous avons dû reconfigurer GCC pour qu'elle fasse de la
compilation croisée.

Les fichiers binaires de cette compilation de GCC sont en annexe du projet, et
ils sont en théorie censés convenir pour les machines tournant sous Unix. Si
cela ne fonctionne pas, il vous suffit de vous-même recompiler GCC pour
i386-elf.

\subsubsection{Makefiles}

Martin Janin

\subsubsection{GRUB}

Martin Janin

\subsection{Ordonancement}

Pour l'ordonancement des processus, nous avons théorisé et commencé à
implémenter une interface d'ordonnancement non préemptive. L'objectif des appels
systèmes implmentés est de permettre l'utilisation d'autres ordonnanceurs
preemptifs, du coté utilisateur. Ainsi, ces ordonnanceurs pourraient etre
rajouter à la librairie C.
Une interface spécifique est également prévu avec les pilotes de périphériques
pour permettre par exemple au processus de configurer des comptes à rebour.

\subsection{Gestion de la mémoire}

\subsubsection{Pagination}

À l'heure actuelle, la pagination est presque fonctionnelle. Les structures
nécessaires à son implémentation sont présente, et ne manquent plus que les
fonctions pour manipuler les pages.

Dans notre version de la pagination, nous nous sommes placé dans le cadre
suivant~:
\begin{itemize}
  \item Les processus ont un tas et une pile de taille fixée (à mille pages soit
    4 kio), considérée comme sufisamment grande pour qu'ils n'aient pas besoin
    de demander plus de place
  \item Les processus sont placés les uns à la suite des autres dans la mémoire.
\end{itemize}

\subsubsection{Allocation mémoire}

L'allocation mémoire est une adaptation de la version la plus performante
présentée dans le cours \emph{Langages de programmation et compilation} de
Jean-Christophe Filliâtre. Elle se base sur la découpe de la mémoire en blocs de
quatre octets et sur une utilisation intelligente de l'espace contenu dans les
blocs libres.

\subsection{Interface utilisateur-machine}

Antonin Reitz

\section{Perspectives d'amélioration}

\subsection{Ce qu'il faudrait coder à court terme}

Actuellement, l'interface de l'ordanceur n'est pas complétement implémentée et
est donc non-fonctionnelle. Quelques heures de travail nous manquent pour avoir
une gestion complète de la mémoire et des processus.

Également, un bug non résolu demeure dans le chargement en mémoire de la section
\texttt{.data} du noyau par GRUB. Ce bug doit être résolu pour permettre de
tester l'ordonanceur et la mémoire.

\subsection{Les fonctionalités à rajouter}

Nous aurions aimé avoir d'un système de fichier non-virtuel. Nous voulions coder
nos pilotes de disque dur puis implémenter ext2 et éventuellement ext3.

La bibliothèque C (\texttt{libc}) a été à peine entamée. De nombreuses
structures et fonctions restent à coder pour rendre le noyau pleinement
fonctionnel et espérer lancer un processus utilisateur.

Lorsque l'espace utilisateur sera disponimbe, il faudra également porter le
shell et éventuellement les pilotes du côté utilisateur.

\subsection{Les erreurs qu'on ne commettra plus}

\end{document}
